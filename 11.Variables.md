# Chapter 11 Variables

## Immutability

In the previous chapters we've made considerable progress on the infrastructure of our language.

Already we can do a number of cool things that other languages can't, such as putting code inside lists. Now is the time to start adding in the features which will make our language practical. The first one of these is going to be variables.

They're called variables, but it's a misleading name, because our variables won't vary. Our variables are immutable meaning they cannot change. Everything in our language so far has acted as if it is immutable. When we evaluate an expression we have imagined that the previous thing has been deleted and a new thing returned. In implementation often it is easier for us to reuse the data from the previous thing to build the new thing, but conceptually it is a good way to think about how our language works.

So actually our variables are simply a way of naming values. They let us assign a name to a value, and then let us get a copy of that value later on when we need it.

To allow for naming values we need to create a structure which stores the name and value of everything named in our program. We call this the environment. When we start a new interactive prompt we want to create a new environment to go along with it, in which each new bit of input is evaluated. Then we can store and recall variables as we program.

> #### What happens when we re-assign a name to something new? Isn't this like mutability?
> In our Lisp, when we re-assign a name we're going to delete the old association and create a new one. This gives the illusion that the thing assigned to that name has changed, and is mutable, but in fact we have deleted the old thing and assigned it a new thing. This is different to C where we really can change the data pointed to by a pointer, or stored in a struct, without deleting it and creating a new one.

## Symbol Syntax

Now that we're going to allow for user defined variables we need to update the grammar for symbols to be more flexible. Rather than just our builtin functions it should match any possible valid symbol. Unlike in C, where the name a variable can be given is fairly restrictive, we're going to allow for all sorts of characters in the name of a variable.

We can create a regular expression that expresses the range of characters available as follows.

```
/[a-zA-Z0-9_+\\-*\\/\\\\=<>!&]+/
```

On first glance this looks like we've just bashed our hands into keyboard. Actually it is a regular expression using a big range specifier `[]`. Inside range specifiers special characters lose their meaning, but some of these characters still need to be escaped with backslashes. Because this is part of a C string we need to put two backslashes to represent a single backslash character in the input.

This rule lets symbols be any of the normal C identifier characters `a-zA-Z0-9_` the arithmetic operator characters `+\\-*\\/` the backslash character `\\\\` the comparison operator characters `=<>!` or an ampersands `&`. This will give us all the flexibility we need for defining new and existing symbols.

```c
mpca_lang(MPCA_LANG_DEFAULT,
  "                                                     \
    number : /-?[0-9]+/ ;                               \
    symbol : /[a-zA-Z0-9_+\\-*\\/\\\\=<>!&]+/ ;         \
    sexpr  : '(' <expr>* ')' ;                          \
    qexpr  : '{' <expr>* '}' ;                          \
    expr   : <number> | <symbol> | <sexpr> | <qexpr> ;  \
    lispy  : /^/ <expr>* /$/ ;                          \
  ",
  Number, Symbol, Sexpr, Qexpr, Expr, Lispy);
```

## Function Pointers

Once we introduce variables, symbols will no longer represent functions in our language, but rather they will represent a name for us to look up into our environment and get some new value back from.

Therefore we need a new value to represent functions in our language, which we can return once one of the builtin symbols is encountered. To create this new type of `lval` we are going to use something called a *function pointer*.

Function pointers are a great feature of C that lets you store and pass around pointers to functions. It doesn't make sense to edit the data pointed to by these pointers. Instead we use them to call the function they point to, as if it were a normal function.

Like normal pointers, function pointers have some type associated with them. This type specifies the type of the function pointed to, not the type of the data pointed to. This lets the compiler work out if it has been called correctly.

In the previous chapter our builtin functions took a lval* as input and returned a `lval*` as output. In this chapter our builtin functions will take an extra pointer to the environment `lenv*` as input. We can declare a new function pointer type called `lbuiltin`, for this type of function, like this.

```c
typedef lval*(*lbuiltin)(lenv*, lval*);
```

> #### Why is that syntax so odd?
> In some places the syntax of C can look particularly weird. It can help if we understand exactly why the syntax is like this. Let us de-construct the syntax in the example above part by part.
> First the `typedef`. This can be put before any standard variable declaration. It results in the name of the variable, being declared a new type, matching what would be the inferred type of that variable. This is why in the above declaration what looks like the function name becomes the new type name.
> Next all those `*`. Pointer types in C are actually meant to be written with the star `*` on the left hand side of the variable name, not the right hand side of the type `int *x;`. This is because C type syntax works by a kind of inference. Instead of reading "Create a new `int` pointer `x`". It is meant to read "Create a new variable `x` where to dereference `x` results in an `int`." Therefore `x` is inferred to be a pointer to an `int`.
> This idea is extended to function pointers. We can read the above declaration as follows. "To get an `lval*` we dereference `lbuiltin` and call it with a `lenv*` and a `lval*`." Therefore lbuiltin must be a function pointer that takes an `lenv*` and a `lval*` and returns a `lval*`.

## Cyclic Types

The `lbuiltin` type references the `lval` type and the lenv type. This means that they should be declared first in the source file.

But we want to make a `lbuiltin` field in our `lval` struct so we can create function values. So therefore our lbuiltin declaration must go before our `lval` declaration. This leads to what is called a cyclic type dependency, where two types depend on each other.

We've come across this problem before with functions which depend on each other. The solution was to create a *forward declaration* which declared a function but left the body of it empty.

In C we can do exactly the same with types. First we declare two `struct` types without a body. Secondly we typedef these to the names `lval` and `lenv`. Then we can define our `lbuiltin` function pointer type. And finally we can define the body of our `lval` struct. Now all our type issues are resolved and the compiler won't complain any more.

```c
/* Forward Declarations */

struct lval;
struct lenv;
typedef struct lval lval;
typedef struct lenv lenv;

/* Lisp Value */

enum { LVAL_ERR, LVAL_NUM,   LVAL_SYM,
       LVAL_FUN, LVAL_SEXPR, LVAL_QEXPR };

typedef lval*(*lbuiltin)(lenv*, lval*);

struct lval {
  int type;

  long num;
  char* err;
  char* sym;
  lbuiltin fun;

  int count;
  lval** cell;
};
```

## Function Type

As we've added a new possible `lval` type with the enumeration `LVAL_FUN`. We should update all our relevant functions that work on `lvals` to deal correctly with this update. In most cases this just means inserting new cases into switch statements.

We can start by making a new constructor function for this type.

```c
lval* lval_fun(lbuiltin func) {
  lval* v = malloc(sizeof(lval));
  v->type = LVAL_FUN;
  v->fun = func;
  return v;
}
```

On **deletion** we don't need to do anything special for function pointers.

```c
case LVAL_FUN: break;
```

On **printing** we can just print out a nominal string.

```c
case LVAL_FUN:   printf("<function>"); break;
```

We're also going to add a new function for copying an `lval`. This is going to come in useful when we put things into, and take things out of, the environment. For numbers and functions we can just copy the relevant fields directly. For strings we need to copy using `malloc` and `strcpy`. To copy lists we need to allocate the correct amount of space and then copy each element individually.

```c
lval* lval_copy(lval* v) {

  lval* x = malloc(sizeof(lval));
  x->type = v->type;

  switch (v->type) {

    /* Copy Functions and Numbers Directly */
    case LVAL_FUN: x->fun = v->fun; break;
    case LVAL_NUM: x->num = v->num; break;

    /* Copy Strings using malloc and strcpy */
    case LVAL_ERR:
      x->err = malloc(strlen(v->err) + 1);
      strcpy(x->err, v->err); break;

    case LVAL_SYM:
      x->sym = malloc(strlen(v->sym) + 1);
      strcpy(x->sym, v->sym); break;

    /* Copy Lists by copying each sub-expression */
    case LVAL_SEXPR:
    case LVAL_QEXPR:
      x->count = v->count;
      x->cell = malloc(sizeof(lval*) * x->count);
      for (int i = 0; i < x->count; i++) {
        x->cell[i] = lval_copy(v->cell[i]);
      }
    break;
  }

  return x;
}
```

## Environment

